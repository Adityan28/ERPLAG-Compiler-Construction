<program>  -->  <moduleDeclarations> <otherModules><driverModule><otherModules>

<moduleDeclarations> -->  <moduleDeclaration><moduleDeclarations> | ε

<moduleDeclaration>  -->  DECLARE MODULE ID SEMICOL

<otherModules> -->  <module><otherModules>| ε

<driverModule> -->  DEF DRIVER PROGRAM ENDDEF <moduleDef>

<module> -->  DEF MODULE ID ENDDEF TAKES INPUT SQBO <input_plist> SQBC SEMICOL <ret> <moduleDef>

<ret> -->  RETURNS SQBO <output_plist> SQBC SEMICOL | ε

<input_plist> -->  ID COLON <dataType>  <M>
<M> --> COMMA ID COLON <dataType> <M>|ε

<output_plist> -->  ID COLON <type> <M1>
<M1> --> COMMA ID COLON <type> <M1>|ε

<dataType> -->  INTEGER | REAL | BOOLEAN | ARRAY SQBO <range> SQBC OF <type>

<type> -->  INTEGER | REAL | BOOLEAN

<moduleDef> -->  START <statements> END

<statements> --> <statement> <statements> | ε

<statement> --> <ioStmt>|<simpleStmt>|<declareStmt>|<condionalStmt>|<iterativeStmt>

<ioStmt> --> GET_VALUE BO ID BC SEMICOL | PRINT BO <var> BC SEMICOL

<var> -->  ID <whichId> | NUM | RNUM

<whichId> -->  SQBO ID SQBC | ε

<simpleStmt> -->  <assignmentStmt> | <moduleReuseStmt>

<assignmentStmt>  -->  ID <whichStmt>

<whichStmt> --> <lvalueIDStmt> | <lvalueARRStmt>

<lvalueIDStmt> -->  ASSIGNOP <expression> SEMICOL

<lvalueARRStmt>  -->  SQBO <index> SQBC ASSIGNOP <expression> SEMICOL

<index> -->  NUM | ID

<moduleReuseStmt>  --> <optional> USE MODULE ID WITH PARAMETERS <idList>SEMICOL

<optional> -->  SQBO <idList> SQBC ASSIGNOP | ε

<idList> --> ID<L>
<L> -->  COMMA ID <L>|ε

<expression> --> <arithBoolExpr> | MINUS BO <arithmeticExpr> BC
<arithBoolExpr> --> <arithBoolExpr> <logicalOp> <select> | <select>
<select> --> <select> <relationalOp> <arithmeticExpr> | <arithmeticExpr>
<arithBoolExpr> --> BO <arithBoolExpr> BC


<arithmeticExpr> --> <term> <K>
<K> --> > <op> <term><K>| <K>

<term> --> <factor><R>
<R>-><op><factor> <R>|ε

<factor> --> BO <arithmeticExpr> BC| <var>

<op> -->  PLUS | MINUS | MUL | DIV

<logicalOp> --> AND | OR

<relationalOp> -->  LT | LE | GT | GE | EQ | NE

<declareStmt> -->  DECLARE <idList> COLON <dataType> SEMICOL

<condionalStmt> --> SWITCH BO ID BC START <caseStmt><default> END

<caseStmt> --> CASE <value> COLON <statements> BREAK SEMICOL <caseStmt>

<value> --> NUM | TRUE | FALSE

<default> --> DEFAULT COLON <statements> BREAK SEMICOL | ε

<iterativeStmt> --> FOR BO ID IN <range> BC START <statements> END |WHILE BO <booleanExpr> BC START <statements> END

<range> --> NUM RANGEOP NUM
